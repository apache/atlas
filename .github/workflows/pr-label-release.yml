name: PR Label Release

on:
  pull_request:
    types: [labeled]
    branches:
      - master
  workflow_run:
    workflows: ["Java CI with Maven"]
    types: [completed]
    branches:
      - ring-*

concurrency:
  group: pr-label-release-${{ github.head_ref || github.ref }}
  cancel-in-progress: false

jobs:
  get-pr-number:
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'pull_request' && startsWith(github.head_ref, 'ring-'))
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
    steps:
      - name: Get PR Number
        id: get-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            let prNumber;

            if (context.eventName === 'pull_request') {
              prNumber = context.issue.number;
            } else {
              // For workflow_run events, context.ref is the default branch (master),
              // not the branch that triggered the build. Use head_branch from the
              // triggering workflow instead.
              const branchName = context.eventName === 'workflow_run'
                ? context.payload.workflow_run.head_branch
                : context.ref.replace('refs/heads/', '');
              console.log(`Looking for PR associated with branch: ${branchName}`);

              const { data: pulls } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${branchName}`,
                state: 'open'
              });

              if (pulls.length === 0) {
                console.log(`No open PR found for branch: ${branchName}`);
                core.setOutput('pr_number', '');
                return;
              }

              prNumber = pulls[0].number;
              console.log(`Found PR #${prNumber} for branch: ${branchName}`);
            }

            console.log(`PR Number: ${prNumber}`);
            core.setOutput('pr_number', prNumber);

  check-prerequisites:
    needs: get-pr-number
    if: needs.get-pr-number.outputs.pr_number != ''
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.check.outputs.should_proceed }}
    steps:
      - name: Check prerequisites
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const prNumber = parseInt('${{ needs.get-pr-number.outputs.pr_number }}');

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const headRef = pr.head.ref;
            console.log(`Head ref: ${headRef}`);

            if (!headRef.startsWith('ring-')) {
              console.log(`Branch ${headRef} is not a ring branch`);
              core.setOutput('should_proceed', 'false');
              return;
            }

            const hasCohortLabel = pr.labels.some(label => label.name.startsWith('cohort:'));
            console.log(`Has cohort label: ${hasCohortLabel}`);

            if (!hasCohortLabel) {
              console.log('No cohort labels found on PR');
              core.setOutput('should_proceed', 'false');
              return;
            }

            // Check if build workflow has completed successfully for the current HEAD SHA
            const buildWorkflowId = 'maven.yml';
            const headSha = pr.head.sha;
            console.log(`Checking build workflow: ${buildWorkflowId} for SHA: ${headSha}`);
            const { data: workflows } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: buildWorkflowId,
              head_sha: headSha,
              status: 'completed',
              per_page: 1
            });

            if (workflows.workflow_runs.length > 0) {
              console.log(`Build workflow run found for current SHA: ${workflows.workflow_runs[0].html_url}`);
            }

            const hasSuccessfulBuild = workflows.workflow_runs.length > 0 &&
                                      workflows.workflow_runs[0].conclusion === 'success';

            if (!hasSuccessfulBuild) {
              console.log(`Build workflow (${buildWorkflowId}) not completed successfully for SHA ${headSha}`);
              core.setOutput('should_proceed', 'false');
              return;
            }

            console.log('All prerequisites met for release');
            core.setOutput('should_proceed', 'true');

  parse-labels:
    needs: [check-prerequisites, get-pr-number]
    if: needs.get-pr-number.outputs.pr_number != '' && needs.check-prerequisites.outputs.should_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      cohort_labels: ${{ steps.parse.outputs.cohort_labels }}
    steps:
      - name: Get PR labels
        id: get_labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const prNumber = parseInt('${{ needs.get-pr-number.outputs.pr_number }}');

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const labels = pr.labels.map(label => label.name);
            core.setOutput('labels', JSON.stringify(labels));
            console.log(`PR labels: ${JSON.stringify(labels)}`);

      - name: Parse labels
        id: parse
        run: |
          COHORTS=$(echo '${{ steps.get_labels.outputs.labels }}' | jq -c '
            map(
              split(":") |
              select(length == 4 and .[0] == "cohort") |
              {source: .[1], key: .[2], value: .[3]}
            )
          ')

          if [ -z "$COHORTS" ] || [ "$COHORTS" = "null" ]; then
            COHORTS="[]"
          fi

          echo "cohort_labels<<EOF" >> $GITHUB_OUTPUT
          echo "$COHORTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Cohort labels: ${COHORTS}"

  trigger-release:
    needs: [check-prerequisites, parse-labels, get-pr-number]
    if: needs.get-pr-number.outputs.pr_number != '' && needs.parse-labels.outputs.cohort_labels != '[]'
    strategy:
      matrix:
        cohort: ${{ fromJson(needs.parse-labels.outputs.cohort_labels) }}
      fail-fast: false
    runs-on: ubuntu-latest
    timeout-minutes: 90
    env:
      VCLUSTER_PROJECT: ${{ vars.VCLUSTER_PROJECT }}
    steps:
      - name: Get Image Tag details
        id: get_image_tag
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const prNumber = parseInt('${{ needs.get-pr-number.outputs.pr_number }}');

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const repoName = context.repo.repo;
            const serviceName = 'atlas';
            const ringName = pr.head.ref;
            const imageRepo = `ghcr.io/atlanhq/${repoName}-${ringName}`;

            let imageTag = '';
            if (pr.state === 'closed') {
              console.log('PR is closed, setting image_tag to empty string');
            } else {
              const commitHash = pr.head.sha.substring(0, 7);
              imageTag = `${commitHash}abcd`;
            }

            core.setOutput('service_name', serviceName);
            core.setOutput('image_tag', imageTag);
            core.setOutput('image_repo', imageRepo);
            core.setOutput('ring_name', ringName);
            core.setOutput('pull_request_url', pr.html_url);

            console.log(`Repo: ${repoName}, Service: ${serviceName}, Tag: ${imageTag}, Image: ${imageRepo}, Ring: ${ringName}`);

      # Resolve the tenant list now so the health check step has it after Temporal finishes.
      # Only 'github' cohort source is supported (reads cohorts/<value>.json from atlan-releases).
      - name: Get tenant list from cohort file
        id: get_tenants
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const source = '${{ matrix.cohort.source }}';
            const key    = '${{ matrix.cohort.key }}';
            const value  = '${{ matrix.cohort.value }}';

            if (source !== 'github' || key !== 'path') {
              console.log(`Cohort source '${source}/${key}' does not support automatic health checks. Skipping.`);
              core.setOutput('tenant_names', '');
              return;
            }

            const filePath = `cohorts/${value}.json`;
            console.log(`Fetching cohort file: ${filePath}`);

            const { data: file } = await github.rest.repos.getContent({
              owner: 'atlanhq',
              repo: 'atlan-releases',
              path: filePath,
              ref: 'main'
            });

            const content = Buffer.from(file.content, 'base64').toString('utf-8');
            const cohortFile = JSON.parse(content);
            const tenantNames = cohortFile.tenants.map(t => t.name).join(',');

            console.log(`Tenants in cohort: ${tenantNames}`);
            core.setOutput('tenant_names', tenantNames);

      - name: Setup tools
        run: |
          # Temporal CLI
          curl -sSf https://temporal.download/cli.sh | sh
          echo "$HOME/.temporalio/bin" >> $GITHUB_PATH

          # kubectl
          curl -sLO "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/kubectl

          # vCluster CLI
          curl -sL -o vcluster "https://github.com/loft-sh/vcluster/releases/latest/download/vcluster-linux-amd64"
          chmod +x vcluster && sudo mv vcluster /usr/local/bin/vcluster

          # jq (pre-installed on ubuntu-latest but ensure it)
          sudo apt-get install -y jq

          # Verify installations (use full path for temporal since GITHUB_PATH applies to next step)
          $HOME/.temporalio/bin/temporal --version
          kubectl version --client
          vcluster --version

      - name: Connect to VPN
        env:
          VCLUSTER_PLATFORM_URL: ${{ secrets.VCLUSTER_PLATFORM_URL }}
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y openconnect
          echo "${{ secrets.GLOBALPROTECT_PASSWORD }}" | sudo openconnect \
            --protocol=gp \
            --user="${{ secrets.GLOBALPROTECT_USERNAME }}" \
            --passwd-on-stdin \
            --background \
            "${{ vars.GLOBALPROTECT_PORTAL_URL }}"

          echo "Waiting for VPN connection to stabilize..."
          sleep 20

          if ! pgrep -x openconnect > /dev/null; then
            echo "ERROR: VPN process exited unexpectedly"
            exit 1
          fi
          echo "VPN connected (PID: $(pgrep -x openconnect))"

          # Configure routing for vCluster Platform (172.17.0.0/16)
          # Docker uses this range by default, must route to VPN instead
          VPN_INTERFACE=$(ip addr show | grep -E '^[0-9]+: tun' | head -1 | cut -d: -f2 | tr -d ' ' || echo "tun0")
          echo "Using VPN interface: $VPN_INTERFACE"

          sudo ip route del 172.17.0.0/16 dev docker0 2>/dev/null || true
          sudo ip route add 172.17.0.0/16 dev $VPN_INTERFACE

          # Verify connectivity to vCluster Platform
          if curl -k -sS $VCLUSTER_PLATFORM_URL -o /dev/null --max-time 30; then
            echo "‚úì VPN connected and vCluster Platform reachable"
          else
            echo "ERROR: Cannot reach vCluster Platform"
            exit 1
          fi

      - name: Login to vCluster Platform
        run: |
          vcluster platform login ${{ secrets.VCLUSTER_PLATFORM_URL }} \
            --access-key ${{ secrets.VCLUSTER_ACCESS_KEY }}
          echo "vCluster platform login successful"

      - name: Trigger Temporal workflow
        id: trigger_temporal
        run: |
          WORKFLOW_ID="service-release-parent-${{ steps.get_image_tag.outputs.service_name }}-$(date +%s)"

          ARGS=$(jq -n \
            --arg ring_name "${{ steps.get_image_tag.outputs.ring_name }}" \
            --arg service_name "${{ steps.get_image_tag.outputs.service_name }}" \
            --arg image_tag "${{ steps.get_image_tag.outputs.image_tag }}" \
            --arg image_repo "${{ steps.get_image_tag.outputs.image_repo }}" \
            --arg source "${{ matrix.cohort.source }}" \
            --arg type "${{ matrix.cohort.key == 'type' && matrix.cohort.value || '' }}" \
            --arg channel "${{ matrix.cohort.key == 'channel' && matrix.cohort.value || '' }}" \
            --arg cloud "${{ matrix.cohort.key == 'cloud' && matrix.cohort.value || '' }}" \
            --arg tenant_names "" \
            --arg pull_request_url "${{ steps.get_image_tag.outputs.pull_request_url }}" \
            --arg path "${{ matrix.cohort.key == 'path' && matrix.cohort.value || '' }}" \
            '{
              ringName: $ring_name,
              serviceName: $service_name,
              imageTag: $image_tag,
              imageRepo: $image_repo,
              cohortSource: $source,
              workspaceType: $type,
              channel: $channel,
              cloud: $cloud,
              tenantNames: ($tenant_names
                | split(",")
                | map(. | gsub("^ +| +$";""))
                | map(select(. != ""))),
              pullRequestUrl: $pull_request_url,
              path: $path
            }')

          echo "Triggering workflow: $WORKFLOW_ID"
          echo "Arguments: $ARGS"

          OUTPUT=$(temporal workflow start --tls \
            --address "temporal-server.atlan.com" \
            --namespace "default" \
            --task-queue "control-plane-worker" \
            --type "ServiceReleaseWorkflow" \
            --workflow-id "$WORKFLOW_ID" \
            --input "$ARGS")

          echo "$OUTPUT"
          RUN_ID=$(echo "$OUTPUT" | grep -i "RunId" | awk '{print $2}')
          echo "Workflow triggered: https://temporal.atlan.com/namespaces/default/workflows/${WORKFLOW_ID}/${RUN_ID}/history"

          echo "workflow_id=$WORKFLOW_ID" >> $GITHUB_OUTPUT

      - name: Wait for Temporal workflow to complete
        run: |
          WORKFLOW_ID="${{ steps.trigger_temporal.outputs.workflow_id }}"
          MAX_WAIT=3600  # 60 minutes
          ELAPSED=0
          POLL_INTERVAL=30

          echo "Polling Temporal workflow: $WORKFLOW_ID"

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            DESCRIBE=$(temporal workflow describe --tls \
              --address "temporal-server.atlan.com" \
              --namespace "default" \
              --workflow-id "$WORKFLOW_ID" 2>&1)

            STATUS_LINE=$(echo "$DESCRIBE" | grep -E "^\s*Status" | head -1)
            echo "[$ELAPSED s] $STATUS_LINE"

            if echo "$STATUS_LINE" | grep -qi "Completed"; then
              echo "Temporal workflow completed successfully"
              exit 0
            fi

            if echo "$STATUS_LINE" | grep -qiE "FAILED|TERMINATED|TIMED_OUT|CANCELED"; then
              echo "Temporal workflow ended with non-success status"
              echo "$DESCRIBE"
              exit 1
            fi

            sleep $POLL_INTERVAL
            ELAPSED=$((ELAPSED + POLL_INTERVAL))
          done

          echo "Timed out waiting for Temporal workflow after ${MAX_WAIT}s"
          exit 1

      - name: Run cohort health checks
        id: health_check
        if: steps.get_tenants.outputs.tenant_names != ''
        run: |
          TENANTS="${{ steps.get_tenants.outputs.tenant_names }}"
          EXPECTED_IMAGE="${{ steps.get_image_tag.outputs.image_repo }}:${{ steps.get_image_tag.outputs.image_tag }}"

          echo "Expected image: $EXPECTED_IMAGE"
          echo "Tenants to check: $TENANTS"
          echo ""

          IFS=',' read -ra TENANT_LIST <<< "$TENANTS"
          PASSED=0
          FAILED=0
          PORT=21100

          # Results file avoids multi-line output escaping issues
          RESULTS_FILE="/tmp/cohort-health-results.md"
          echo "" > "$RESULTS_FILE"

          for TENANT in "${TENANT_LIST[@]}"; do
            TENANT=$(echo "$TENANT" | xargs)
            PORT=$((PORT + 1))

            echo "============================================="
            echo "Checking tenant: $TENANT"
            echo "============================================="

            # --- Connect to tenant vCluster ---
            KUBECONFIG="kubeconfig-${TENANT}.yaml"
            if ! KUBECONFIG=$KUBECONFIG vcluster platform connect vcluster "$TENANT" \
                --project "$VCLUSTER_PROJECT" 2>&1; then
              echo "FAIL: vCluster connection failed for $TENANT"
              FAILED=$((FAILED + 1))
              echo "- ‚ùå **${TENANT}**: vCluster connection failed" >> "$RESULTS_FILE"
              continue
            fi

            # --- Pod readiness: all pods must exist and have all containers ready ---
            PODS_JSON=$(KUBECONFIG=$KUBECONFIG kubectl get pods -n atlas -l app=atlas -o json 2>/dev/null)
            if [ $? -ne 0 ]; then
              echo "FAIL: kubectl get pods failed for $TENANT"
              FAILED=$((FAILED + 1))
              echo "- ‚ùå **${TENANT}**: kubectl get pods failed" >> "$RESULTS_FILE"
              continue
            fi

            TOTAL_PODS=$(echo "$PODS_JSON" | jq '.items | length')
            NOT_READY=$(echo "$PODS_JSON" | jq '[.items[].status.containerStatuses[]? | select(.ready == false)] | length')
            READY=$(echo "$PODS_JSON"     | jq '[.items[].status.containerStatuses[]? | select(.ready == true)]  | length')
            TOTAL_CONTAINERS=$(echo "$PODS_JSON" | jq '[.items[].status.containerStatuses[]?] | length')

            echo "Pods: $TOTAL_PODS | Containers ready: $READY/$TOTAL_CONTAINERS"

            if [ "$TOTAL_PODS" == "0" ]; then
              echo "FAIL: No atlas pods found for $TENANT"
              FAILED=$((FAILED + 1))
              echo "- ‚ùå **${TENANT}**: No atlas pods found" >> "$RESULTS_FILE"
              continue
            fi

            if [ "$NOT_READY" != "0" ]; then
              echo "FAIL: Pod readiness check failed ($NOT_READY containers not ready)"
              FAILED=$((FAILED + 1))
              echo "- ‚ùå **${TENANT}**: Pods not ready (${TOTAL_PODS} pods, ${READY}/${TOTAL_CONTAINERS} containers ready)" >> "$RESULTS_FILE"
              continue
            fi

            echo "OK: $TOTAL_PODS pods, all containers ready ($READY/$TOTAL_CONTAINERS)"

            # --- Image verification: atlas-main container must have correct repo-ring and tag ---
            # Image format: ghcr.io/atlanhq/{repo}-{ring_name}:{commit_hash}abcd
            # ECR cached:   ...ecr.../ghcr-cache/ghcr.io/atlanhq/{repo}-{ring_name}:{commit_hash}abcd
            #
            # We verify:
            # 1. Image path contains "{repo}-{ring_name}" (e.g., atlas-metastore-ring-test)
            # 2. Image tag matches expected tag (e.g., e80de26abcd)
            REPO_NAME="${{ github.event.repository.name }}"
            RING_NAME="${{ steps.get_image_tag.outputs.ring_name }}"
            EXPECTED_TAG="${{ steps.get_image_tag.outputs.image_tag }}"
            EXPECTED_IMAGE_PATTERN="${REPO_NAME}-${RING_NAME}"

            echo "Verifying image: pattern='$EXPECTED_IMAGE_PATTERN', tag='$EXPECTED_TAG'"

            ACTUAL_IMAGES=$(echo "$PODS_JSON" | jq -r \
              '.items[].status.containerStatuses[]? | select(.name == "atlas-main") | .image')

            MISMATCH_COUNT=0
            for IMG in $ACTUAL_IMAGES; do
              ACTUAL_TAG="${IMG##*:}"
              
              # Check if image path contains the expected pattern (repo-ring)
              if [[ "$IMG" != *"$EXPECTED_IMAGE_PATTERN"* ]]; then
                echo "  Image '$IMG' does not contain pattern '$EXPECTED_IMAGE_PATTERN'"
                MISMATCH_COUNT=$((MISMATCH_COUNT + 1))
                continue
              fi

              # Check if tag matches
              if [ "$ACTUAL_TAG" != "$EXPECTED_TAG" ]; then
                echo "  Image '$IMG' has wrong tag: expected '$EXPECTED_TAG', got '$ACTUAL_TAG'"
                MISMATCH_COUNT=$((MISMATCH_COUNT + 1))
                continue
              fi
            done

            if [ "$MISMATCH_COUNT" != "0" ]; then
              ACTUAL_UNIQUE=$(echo "$ACTUAL_IMAGES" | sort -u | tr '\n' ' ')
              echo "FAIL: Image mismatch. Expected pattern: $EXPECTED_IMAGE_PATTERN:$EXPECTED_TAG"
              echo "      Actual images: $ACTUAL_UNIQUE"
              FAILED=$((FAILED + 1))
              echo "- ‚ùå **${TENANT}**: Image mismatch (expected: \`$EXPECTED_IMAGE_PATTERN:$EXPECTED_TAG\`)" >> "$RESULTS_FILE"
              continue
            fi

            echo "OK: All $TOTAL_PODS pods running correct ring image ($EXPECTED_IMAGE_PATTERN:$EXPECTED_TAG)"

            # --- App health check: port-forward + /api/atlas/admin/status ---
            KUBECONFIG=$KUBECONFIG kubectl port-forward \
              -n atlas svc/atlas-service-atlas $PORT:80 > /dev/null 2>&1 &
            PF_PID=$!

            PF_READY=false
            for i in $(seq 1 30); do
              if lsof -i :$PORT &>/dev/null; then
                PF_READY=true
                break
              fi
              sleep 1
            done

            if [ "$PF_READY" != "true" ]; then
              echo "FAIL: Port-forward did not become ready for $TENANT"
              kill $PF_PID 2>/dev/null || true
              FAILED=$((FAILED + 1))
              echo "- ‚ùå **${TENANT}**: Port-forward failed" >> "$RESULTS_FILE"
              continue
            fi

            APP_STATUS=""
            for attempt in $(seq 1 6); do
              RESP=$(curl -sf "http://localhost:$PORT/api/atlas/admin/status" 2>/dev/null)
              if [ $? -eq 0 ]; then
                APP_STATUS=$(echo "$RESP" | jq -r '.Status' 2>/dev/null)
                if [ "$APP_STATUS" = "ACTIVE" ]; then
                  break
                fi
                echo "  Attempt $attempt/6 ‚Äî Status: ${APP_STATUS:-empty}"
              else
                echo "  Attempt $attempt/6 ‚Äî curl failed"
              fi
              sleep 10
            done

            kill $PF_PID 2>/dev/null || true

            if [ "$APP_STATUS" = "ACTIVE" ]; then
              echo "OK: App status ACTIVE"
              PASSED=$((PASSED + 1))
              echo "- ‚úÖ **${TENANT}**: Healthy (${TOTAL_PODS} pods ready, \`$EXPECTED_IMAGE_PATTERN:$EXPECTED_TAG\`, Status=ACTIVE)" >> "$RESULTS_FILE"
            else
              echo "FAIL: App status '${APP_STATUS:-unreachable}'"
              FAILED=$((FAILED + 1))
              echo "- ‚ùå **${TENANT}**: App not healthy (Status=${APP_STATUS:-unreachable})" >> "$RESULTS_FILE"
            fi

            echo ""
          done

          echo ""
          echo "=============================="
          echo "TOTAL: $((PASSED + FAILED)) | PASSED: $PASSED | FAILED: $FAILED"
          echo "=============================="

          {
            echo "total=$((PASSED + FAILED))"
            echo "passed=$PASSED"
            echo "failed=$FAILED"
          } >> $GITHUB_OUTPUT

          if [ $FAILED -gt 0 ]; then
            exit 1
          fi

      - name: Post health check results to PR
        if: always() && steps.get_tenants.outputs.tenant_names != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const prNumber = parseInt('${{ needs.get-pr-number.outputs.pr_number }}');
            const total    = '${{ steps.health_check.outputs.total }}' || '0';
            const passed   = '${{ steps.health_check.outputs.passed }}' || '0';
            const failed   = '${{ steps.health_check.outputs.failed }}' || '0';
            const ring     = '${{ steps.get_image_tag.outputs.ring_name }}';
            const imageTag = '${{ steps.get_image_tag.outputs.image_tag }}';

            const fs = require('fs');
            let details = '';
            try {
              details = fs.readFileSync('/tmp/cohort-health-results.md', 'utf8').trim();
            } catch (e) {
              details = '_Health check did not produce results._';
            }

            const statusEmoji = failed === '0' ? '‚úÖ' : '‚ùå';
            const statusText  = failed === '0'
              ? `All ${total} tenant(s) healthy`
              : `${failed}/${total} tenant(s) failed`;

            const body = [
              `## üè• Cohort Health Check`,
              ``,
              `**Status:** ${statusEmoji} ${statusText}`,
              `**Ring:** \`${ring}\`  **Image Tag:** \`${imageTag}\``,
              ``,
              details,
              ``,
              `[View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              issue_number: prNumber,
              body
            });
