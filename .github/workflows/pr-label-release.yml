name: PR Label Release

on:
  pull_request:
    types: [labeled]
    branches:
      - master
  workflow_run:
    workflows: ["Java CI with Maven"]
    types: [completed]
    branches:
      - ring-*

concurrency:
  group: pr-label-release-${{ github.head_ref || github.ref }}
  cancel-in-progress: false

jobs:
  get-pr-number:
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'pull_request' && startsWith(github.head_ref, 'ring-'))
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
    steps:
      - name: Get PR Number
        id: get-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            let prNumber;

            if (context.eventName === 'pull_request') {
              prNumber = context.issue.number;
            } else {
              // For workflow_run events, context.ref is the default branch (master),
              // not the branch that triggered the build. Use head_branch from the
              // triggering workflow instead.
              const branchName = context.eventName === 'workflow_run'
                ? context.payload.workflow_run.head_branch
                : context.ref.replace('refs/heads/', '');
              console.log(`Looking for PR associated with branch: ${branchName}`);

              const { data: pulls } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${branchName}`,
                state: 'open'
              });

              if (pulls.length === 0) {
                console.log(`No open PR found for branch: ${branchName}`);
                core.setOutput('pr_number', '');
                return;
              }

              prNumber = pulls[0].number;
              console.log(`Found PR #${prNumber} for branch: ${branchName}`);
            }

            console.log(`PR Number: ${prNumber}`);
            core.setOutput('pr_number', prNumber);

  check-prerequisites:
    needs: get-pr-number
    if: needs.get-pr-number.outputs.pr_number != ''
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.check.outputs.should_proceed }}
    steps:
      - name: Check prerequisites
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const prNumber = parseInt('${{ needs.get-pr-number.outputs.pr_number }}');

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const headRef = pr.head.ref;
            console.log(`Head ref: ${headRef}`);

            if (!headRef.startsWith('ring-')) {
              console.log(`Branch ${headRef} is not a ring branch`);
              core.setOutput('should_proceed', 'false');
              return;
            }

            const hasCohortLabel = pr.labels.some(label => label.name.startsWith('cohort:'));
            console.log(`Has cohort label: ${hasCohortLabel}`);

            if (!hasCohortLabel) {
              console.log('No cohort labels found on PR');
              core.setOutput('should_proceed', 'false');
              return;
            }

            // Check if build workflow has completed successfully for the current HEAD SHA
            // Important: We must check the actual 'build' job, not just the workflow.
            // The workflow can succeed even if 'build' was skipped (e.g., only helm files changed).
            const buildWorkflowId = 'maven.yml';
            const headSha = pr.head.sha;
            console.log(`Checking build workflow: ${buildWorkflowId} for SHA: ${headSha}`);
            const { data: workflows } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: buildWorkflowId,
              head_sha: headSha,
              status: 'completed',
              per_page: 1
            });

            if (workflows.workflow_runs.length === 0) {
              console.log(`No completed workflow runs found for SHA ${headSha}`);
              core.setOutput('should_proceed', 'false');
              return;
            }

            const workflowRun = workflows.workflow_runs[0];
            console.log(`Workflow run found: ${workflowRun.html_url}`);

            // Check if the 'build' job specifically succeeded (not skipped)
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: workflowRun.id
            });

            const buildJob = jobs.jobs.find(job => job.name === 'build');
            if (!buildJob) {
              console.log('Build job not found in workflow run');
              core.setOutput('should_proceed', 'false');
              return;
            }

            console.log(`Build job status: ${buildJob.status}, conclusion: ${buildJob.conclusion}`);

            if (buildJob.conclusion !== 'success') {
              console.log(`Build job did not succeed (conclusion: ${buildJob.conclusion}). Docker image may not exist.`);
              core.setOutput('should_proceed', 'false');
              return;
            }

            console.log('All prerequisites met for release');
            core.setOutput('should_proceed', 'true');

  parse-labels:
    needs: [check-prerequisites, get-pr-number]
    if: needs.get-pr-number.outputs.pr_number != '' && needs.check-prerequisites.outputs.should_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      cohort_labels: ${{ steps.parse.outputs.cohort_labels }}
    steps:
      - name: Get PR labels
        id: get_labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const prNumber = parseInt('${{ needs.get-pr-number.outputs.pr_number }}');
            const eventName = context.eventName;

            let labels = [];

            if (eventName === 'pull_request') {
              // For 'labeled' event, only process the newly added label
              const addedLabel = context.payload.label?.name;
              if (addedLabel) {
                console.log(`Labeled event: processing only newly added label: ${addedLabel}`);
                labels = [addedLabel];
              }
            } else {
              // For 'workflow_run' event, process all cohort labels on the PR
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              labels = pr.labels.map(label => label.name);
              console.log(`Workflow run event: processing all labels`);
            }

            core.setOutput('labels', JSON.stringify(labels));
            console.log(`Labels to process: ${JSON.stringify(labels)}`);

      - name: Parse labels
        id: parse
        run: |
          COHORTS=$(echo '${{ steps.get_labels.outputs.labels }}' | jq -c '
            map(
              split(":") |
              select(length == 4 and .[0] == "cohort") |
              {source: .[1], key: .[2], value: .[3]}
            )
          ')

          if [ -z "$COHORTS" ] || [ "$COHORTS" = "null" ]; then
            COHORTS="[]"
          fi

          echo "cohort_labels<<EOF" >> $GITHUB_OUTPUT
          echo "$COHORTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Cohort labels: ${COHORTS}"

  # Process all cohorts sequentially in a single job to avoid parallel VPN connection issues.
  # GlobalProtect VPN only allows one connection per credential set at a time.
  trigger-release:
    needs: [check-prerequisites, parse-labels, get-pr-number]
    if: needs.get-pr-number.outputs.pr_number != '' && needs.parse-labels.outputs.cohort_labels != '[]'
    runs-on: ubuntu-latest
    timeout-minutes: 90
    steps:
      - name: Get Image Tag details
        id: get_image_tag
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const prNumber = parseInt('${{ needs.get-pr-number.outputs.pr_number }}');

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const repoName = context.repo.repo;
            const serviceName = 'atlas';
            const ringName = pr.head.ref;
            const imageRepo = `ghcr.io/atlanhq/${repoName}-${ringName}`;

            let imageTag = '';
            if (pr.state === 'closed') {
              console.log('PR is closed, setting image_tag to empty string');
            } else {
              const commitHash = pr.head.sha.substring(0, 7);
              imageTag = `${commitHash}abcd`;
            }

            core.setOutput('service_name', serviceName);
            core.setOutput('image_tag', imageTag);
            core.setOutput('image_repo', imageRepo);
            core.setOutput('ring_name', ringName);
            core.setOutput('pull_request_url', pr.html_url);

            console.log(`Repo: ${repoName}, Service: ${serviceName}, Tag: ${imageTag}, Image: ${imageRepo}, Ring: ${ringName}`);

      - name: Setup Temporal CLI
        run: |
          curl -sSf https://temporal.download/cli.sh | sh
          echo "$HOME/.temporalio/bin" >> $GITHUB_PATH
          $HOME/.temporalio/bin/temporal --version

      - name: Connect to VPN
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y openconnect
          echo "${{ secrets.GLOBALPROTECT_PASSWORD }}" | sudo openconnect \
            --protocol=gp \
            --user="${{ secrets.GLOBALPROTECT_USERNAME }}" \
            --passwd-on-stdin \
            --background \
            "vpnsec.atlan.app"
          sleep 5

          # Verify VPN is running
          if ! pgrep -x openconnect > /dev/null; then
            echo "ERROR: OpenConnect exited unexpectedly"
            exit 1
          fi
          echo "VPN connected successfully"

      # Process each cohort sequentially to trigger Temporal workflows
      - name: Trigger Temporal workflows for all cohorts
        id: trigger_temporal
        uses: actions/github-script@v7
        env:
          COHORT_LABELS: ${{ needs.parse-labels.outputs.cohort_labels }}
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const { execSync } = require('child_process');

            const cohorts = JSON.parse(process.env.COHORT_LABELS);
            const ringName = '${{ steps.get_image_tag.outputs.ring_name }}';
            const serviceName = '${{ steps.get_image_tag.outputs.service_name }}';
            const imageTag = '${{ steps.get_image_tag.outputs.image_tag }}';
            const imageRepo = '${{ steps.get_image_tag.outputs.image_repo }}';
            const pullRequestUrl = '${{ steps.get_image_tag.outputs.pull_request_url }}';

            const results = [];

            for (const cohort of cohorts) {
              const workflowId = `service-release-parent-${serviceName}-${Date.now()}`;

              // Resolve tenant names for github:path cohorts
              let tenantNames = '';
              if (cohort.source === 'github' && cohort.key === 'path') {
                try {
                  const { data: file } = await github.rest.repos.getContent({
                    owner: 'atlanhq',
                    repo: 'atlan-releases',
                    path: `cohorts/${cohort.value}.json`,
                    ref: 'main'
                  });
                  const content = Buffer.from(file.content, 'base64').toString('utf-8');
                  const cohortFile = JSON.parse(content);
                  tenantNames = cohortFile.tenants.map(t => t.name).join(',');
                } catch (e) {
                  console.log(`Warning: Could not fetch cohort file for ${cohort.value}: ${e.message}`);
                }
              }

              // Build Temporal workflow arguments
              const args = {
                ringName,
                serviceName,
                imageTag,
                imageRepo,
                cohortSource: cohort.source,
                workspaceType: cohort.key === 'type' ? cohort.value : '',
                channel: cohort.key === 'channel' ? cohort.value : '',
                cloud: cohort.key === 'cloud' ? cohort.value : '',
                tenantNames: [],
                pullRequestUrl,
                path: cohort.key === 'path' ? cohort.value : ''
              };

              console.log(`\n=== Triggering release for cohort: ${cohort.source}:${cohort.key}:${cohort.value} ===`);
              console.log(`Workflow ID: ${workflowId}`);
              console.log(`Arguments: ${JSON.stringify(args, null, 2)}`);

              try {
                const cmd = `temporal workflow start --tls \
                  --address "temporal-server.atlan.com" \
                  --namespace "default" \
                  --task-queue "control-plane-worker" \
                  --type "ServiceReleaseWorkflow" \
                  --workflow-id "${workflowId}" \
                  --input '${JSON.stringify(args)}'`;

                const output = execSync(cmd, { encoding: 'utf-8' });
                console.log(output);

                const runIdMatch = output.match(/RunId\s+(\S+)/i);
                const runId = runIdMatch ? runIdMatch[1] : '';

                results.push({
                  cohort: `${cohort.source}:${cohort.key}:${cohort.value}`,
                  cohortValue: cohort.value,
                  workflowId,
                  runId,
                  tenantNames,
                  success: true
                });
              } catch (e) {
                console.log(`ERROR: Failed to trigger workflow for ${cohort.value}: ${e.message}`);
                results.push({
                  cohort: `${cohort.source}:${cohort.key}:${cohort.value}`,
                  cohortValue: cohort.value,
                  workflowId,
                  runId: '',
                  tenantNames,
                  success: false,
                  error: e.message
                });
              }

              // Small delay between triggers to be safe
              await new Promise(r => setTimeout(r, 1000));
            }

            core.setOutput('results', JSON.stringify(results));
            core.setOutput('ring_name', ringName);
            core.setOutput('image_tag', imageTag);

            // Fail the step if any trigger failed
            const failures = results.filter(r => !r.success);
            if (failures.length > 0) {
              core.setFailed(`Failed to trigger ${failures.length} workflow(s)`);
            }

      # NOTE: We do NOT wait for Temporal workflow to complete here.
      # Waiting would be expensive (60-90+ minutes of GitHub Actions billing).
      # Instead, Temporal handles the full release lifecycle and posts the final
      # result comment to the PR via AddGitHubPRCommentActivity.

      - name: Post release triggered to PR
        if: always()
        uses: actions/github-script@v7
        env:
          TRIGGER_RESULTS: ${{ steps.trigger_temporal.outputs.results }}
        with:
          github-token: ${{ secrets.ORG_PAT_GITHUB }}
          script: |
            const prNumber = parseInt('${{ needs.get-pr-number.outputs.pr_number }}');
            const ring = '${{ steps.get_image_tag.outputs.ring_name }}';
            const imageTag = '${{ steps.get_image_tag.outputs.image_tag }}';
            const jobStatus = '${{ job.status }}';

            let results = [];
            try {
              results = JSON.parse(process.env.TRIGGER_RESULTS || '[]');
            } catch (e) {
              console.log('Could not parse trigger results');
            }

            const successCount = results.filter(r => r.success).length;
            const failCount = results.filter(r => !r.success).length;

            const statusEmoji = failCount === 0 ? 'üöÄ' : (successCount > 0 ? '‚ö†Ô∏è' : '‚ùå');
            const statusText = failCount === 0
              ? 'All releases triggered successfully'
              : (successCount > 0 ? `${successCount} succeeded, ${failCount} failed` : 'All releases failed');

            const cohortDetails = results.map(r => {
              const icon = r.success ? '‚úÖ' : '‚ùå';
              const link = r.success
                ? `[${r.workflowId}](https://temporal.atlan.com/namespaces/default/workflows/${r.workflowId})`
                : `Failed: ${r.error || 'Unknown error'}`;
              return `| ${icon} | \`${r.cohortValue}\` | ${r.tenantNames || '_none_'} | ${link} |`;
            }).join('\n');

            const body = [
              `## ${statusEmoji} Ring Release Triggered`,
              ``,
              `**Status:** ${statusText}`,
              `**Ring:** \`${ring}\`  **Image Tag:** \`${imageTag}\``,
              ``,
              `| Status | Cohort | Tenants | Temporal Workflow |`,
              `|--------|--------|---------|-------------------|`,
              cohortDetails,
              ``,
              `> ‚ÑπÔ∏è Temporal will post the final release status for each cohort once complete.`,
              ``,
              `[View GitHub Actions run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body
            });
