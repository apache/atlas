/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.atlas.web.integration;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.atlas.model.instance.AtlasClassification;
import org.apache.atlas.model.instance.AtlasClassification.AtlasClassifications;
import org.apache.atlas.model.instance.AtlasEntity;
import org.apache.atlas.model.instance.AtlasEntity.AtlasEntityWithExtInfo;
import org.apache.atlas.model.instance.AtlasEntityHeader;
import org.apache.atlas.model.instance.EntityMutationResponse;
import org.apache.atlas.model.typedef.AtlasClassificationDef;
import org.apache.atlas.model.typedef.AtlasTypesDef;
import org.junit.jupiter.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration test for MS-595: classification propagation flag updates produce stale
 * audit data during CLASSIFICATION_UPDATE.
 *
 * <h3>Bug summary</h3>
 * In {@code updateClassificationsV2()} (EntityGraphMapper.java):
 * <ol>
 *   <li>{@code currentClassification} is read from Cassandra — has <b>OLD</b> flags</li>
 *   <li>{@code tagDAO.putDirectTag()} writes the request's {@code classification} with <b>NEW</b> flags to Cassandra</li>
 *   <li>Attribute and validity-period changes are copied onto {@code currentClassification} ✓</li>
 *   <li><b>Propagation flags are NEVER copied onto {@code currentClassification}</b> ✗</li>
 *   <li>{@code updatedClassifications.add(currentClassification)} — stale object sent to notifier</li>
 *   <li>Audit/notification carries the stale propagation flags</li>
 * </ol>
 *
 * <p>Result: Cassandra tags table is correct, but the entity audit (ES) and Kafka notification
 * still show the <b>previous</b> propagation flag values.</p>
 *
 * <h3>Verification approach</h3>
 * <ol>
 *   <li>Create entity with classification {@code propagate=false}</li>
 *   <li>Update classification to {@code propagate=true}</li>
 *   <li>GET API confirms Cassandra has the new value ✓</li>
 *   <li>Query ES entity audit for CLASSIFICATION_UPDATE — parse the classification JSON
 *       in the audit {@code details} field and assert {@code propagate=true}</li>
 *   <li>The audit will show stale {@code propagate=false} due to the bug ✗</li>
 * </ol>
 *
 * @see org.apache.atlas.repository.store.graph.v2.EntityGraphMapper#updateClassificationsV2
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class ClassificationPropagationFlagIntegrationTest extends AtlasInProcessBaseIT {

    private static final Logger LOG = LoggerFactory.getLogger(ClassificationPropagationFlagIntegrationTest.class);
    private static final ObjectMapper MAPPER = new ObjectMapper();

    private final long testId = System.currentTimeMillis();
    private final String classificationDisplayName = "PropFlagTest_" + testId;

    private final HttpClient httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build();

    private boolean typedefCreated = false;
    private String classificationName; // actual type name (auto-generated by Atlas)
    private String entityGuid;

    // =========================================================================
    //  Setup: create classification typedef + entity
    // =========================================================================

    @Test
    @Order(1)
    void testSetup_CreateClassificationTypeAndEntity() throws Exception {
        // Create classification typedef
        // NOTE: AtlasClassificationDef(String) treats the arg as displayName and
        // auto-generates a random name. We must read back the actual name from the
        // response to use it for classification attachment.
        AtlasClassificationDef classDef = new AtlasClassificationDef(classificationDisplayName);
        classDef.setDescription("Test classification for MS-595 propagation flag bug");
        classDef.setServiceType("atlas_core");

        AtlasTypesDef typesDef = new AtlasTypesDef();
        typesDef.setClassificationDefs(Collections.singletonList(classDef));

        AtlasTypesDef created = atlasClient.createAtlasTypeDefs(typesDef);
        assertNotNull(created);
        assertNotNull(created.getClassificationDefs());
        assertEquals(1, created.getClassificationDefs().size());

        // The actual type name is auto-generated — read it from the response
        classificationName = created.getClassificationDefs().get(0).getName();
        assertNotNull(classificationName, "Classification name should not be null");
        LOG.info("Created classification typedef: name={}, displayName={}", classificationName, classificationDisplayName);

        typedefCreated = true;

        Thread.sleep(2000); // Wait for type registry update

        // Create entity with classification: propagate=false
        AtlasClassification classification = new AtlasClassification(classificationName);
        classification.setPropagate(false);
        classification.setRemovePropagationsOnEntityDelete(true);
        classification.setRestrictPropagationThroughLineage(false);
        classification.setRestrictPropagationThroughHierarchy(false);

        AtlasEntity entity = new AtlasEntity("Table");
        entity.setAttribute("name", "propflag-test-table-" + testId);
        entity.setAttribute("qualifiedName", "test://integration/propflag/table/" + testId);
        entity.setClassifications(Collections.singletonList(classification));

        EntityMutationResponse response = atlasClient.createEntity(new AtlasEntityWithExtInfo(entity));
        AtlasEntityHeader createdHeader = response.getFirstEntityCreated();
        assertNotNull(createdHeader, "Entity should be created");
        entityGuid = createdHeader.getGuid();

        LOG.info("Setup complete: typedef={}, entityGuid={}", classificationName, entityGuid);

        // Verify initial state
        AtlasClassifications classifications = atlasClient.getClassifications(entityGuid);
        assertNotNull(classifications);
        assertEquals(1, classifications.getList().size());
        AtlasClassification initial = classifications.getList().get(0);
        assertFalse(initial.isPropagate(), "Initial propagate should be false");
    }

    // =========================================================================
    //  Test: update propagate false → true, verify GET API
    // =========================================================================

    @Test
    @Order(2)
    @DisplayName("GET API should reflect updated propagate=true (Cassandra is correct)")
    void testUpdatePropagateTrue_GetApiShowsCorrectValue() throws Exception {
        Assumptions.assumeTrue(entityGuid != null, "Entity not created");

        // Update: propagate false → true
        AtlasClassification update = new AtlasClassification(classificationName);
        update.setEntityGuid(entityGuid);
        update.setPropagate(true);
        update.setRemovePropagationsOnEntityDelete(true);
        update.setRestrictPropagationThroughLineage(false);
        update.setRestrictPropagationThroughHierarchy(false);

        atlasClient.updateClassifications(entityGuid, Collections.singletonList(update));
        LOG.info("Updated propagate: false → true");

        Thread.sleep(2000); // Allow async processing

        // GET API should show the new value (reads from Cassandra — always correct)
        AtlasClassifications classifications = atlasClient.getClassifications(entityGuid);
        AtlasClassification fetched = classifications.getList().stream()
                .filter(c -> c.getTypeName().equals(classificationName))
                .findFirst()
                .orElseThrow(() -> new AssertionError("Classification not found via GET"));

        assertTrue(fetched.isPropagate(),
                "GET API: propagate should be true after update (Cassandra is correct)");
        LOG.info("GET API verified: propagate=true ✓");
    }

    // =========================================================================
    //  Test: verify the audit ALSO has the correct propagate=true
    //  THIS IS WHERE THE BUG MANIFESTS — audit details contain stale flags
    // =========================================================================

    @Test
    @Order(3)
    @DisplayName("MS-595: entity audit CLASSIFICATION_UPDATE detail must have propagate=true after update")
    void testUpdatePropagateTrue_AuditMustReflectNewValue() throws Exception {
        Assumptions.assumeTrue(entityGuid != null, "Entity not created");

        // Query ES audit for CLASSIFICATION_UPDATE events on this entity
        // The audit detail format is: "Updated classification: {json}"
        // where {json} is AtlasType.toJson(currentClassification) — the stale object
        JsonNode auditClassification = getLatestClassificationUpdateAuditDetail(entityGuid, classificationName);
        assertNotNull(auditClassification,
                "Should find a CLASSIFICATION_UPDATE audit entry for " + classificationName);

        LOG.info("Audit detail classification JSON: {}", auditClassification);

        // The bug: currentClassification in updateClassificationsV2() has the OLD propagate
        // value because propagation flags are never copied from the request classification.
        // Cassandra has propagate=true (correct), but the audit has propagate=false (stale).
        assertTrue(auditClassification.has("propagate"),
                "Audit classification should have 'propagate' field");

        assertEquals(true, auditClassification.get("propagate").asBoolean(),
                "MS-595 BUG: Entity audit CLASSIFICATION_UPDATE detail must show propagate=true. " +
                "In updateClassificationsV2() at line ~5391, currentClassification (which has the OLD " +
                "propagate=false value) is added to updatedClassifications without copying the new " +
                "propagation flags from the request. Cassandra is correct but the audit is stale.");
    }

    // =========================================================================
    //  Test: update propagate true → false, verify audit catches up
    // =========================================================================

    @Test
    @Order(4)
    @DisplayName("MS-595: after second update (propagate=false), audit must show false not the previous true")
    void testUpdatePropagateFalse_AuditMustReflectNewValue() throws Exception {
        Assumptions.assumeTrue(entityGuid != null, "Entity not created");

        // Update: propagate true → false
        AtlasClassification update = new AtlasClassification(classificationName);
        update.setEntityGuid(entityGuid);
        update.setPropagate(false);
        update.setRemovePropagationsOnEntityDelete(true);
        update.setRestrictPropagationThroughLineage(false);
        update.setRestrictPropagationThroughHierarchy(false);

        atlasClient.updateClassifications(entityGuid, Collections.singletonList(update));
        LOG.info("Updated propagate: true → false");

        Thread.sleep(3000); // Allow async processing + ES refresh

        // GET API should show false
        AtlasClassifications classifications = atlasClient.getClassifications(entityGuid);
        AtlasClassification fetched = classifications.getList().stream()
                .filter(c -> c.getTypeName().equals(classificationName))
                .findFirst()
                .orElseThrow(() -> new AssertionError("Classification not found via GET"));
        assertFalse(fetched.isPropagate(), "GET API: propagate should be false");

        // Audit should ALSO show false
        JsonNode auditClassification = getLatestClassificationUpdateAuditDetail(entityGuid, classificationName);
        assertNotNull(auditClassification, "Should find CLASSIFICATION_UPDATE audit");

        assertEquals(false, auditClassification.get("propagate").asBoolean(),
                "MS-595 BUG: Entity audit must show propagate=false after second update. " +
                "With the bug, the audit is always one update behind — it will show " +
                "propagate=true (the previous value) instead of false.");
    }

    // =========================================================================
    //  Test: update restrictPropagationThroughLineage flag
    // =========================================================================

    @Test
    @Order(5)
    @DisplayName("MS-595: audit must reflect updated restrictPropagationThroughLineage=true")
    void testUpdateRestrictLineage_AuditMustReflectNewValue() throws Exception {
        Assumptions.assumeTrue(entityGuid != null, "Entity not created");

        // Update: restrictPropagationThroughLineage false → true
        AtlasClassification update = new AtlasClassification(classificationName);
        update.setEntityGuid(entityGuid);
        update.setPropagate(true); // also set propagate=true to enable lineage restriction
        update.setRemovePropagationsOnEntityDelete(true);
        update.setRestrictPropagationThroughLineage(true);
        update.setRestrictPropagationThroughHierarchy(false);

        atlasClient.updateClassifications(entityGuid, Collections.singletonList(update));
        LOG.info("Updated restrictPropagationThroughLineage: false → true");

        Thread.sleep(3000);

        // GET API should show true
        AtlasClassifications classifications = atlasClient.getClassifications(entityGuid);
        AtlasClassification fetched = classifications.getList().stream()
                .filter(c -> c.getTypeName().equals(classificationName))
                .findFirst()
                .orElseThrow(() -> new AssertionError("Classification not found via GET"));
        assertTrue(fetched.getRestrictPropagationThroughLineage(),
                "GET API: restrictPropagationThroughLineage should be true");

        // Audit should also show true
        JsonNode auditClassification = getLatestClassificationUpdateAuditDetail(entityGuid, classificationName);
        assertNotNull(auditClassification, "Should find CLASSIFICATION_UPDATE audit");

        assertEquals(true, auditClassification.get("propagate").asBoolean(),
                "MS-595 BUG: Entity audit must show propagate=true (also changed in this update)");
        assertTrue(auditClassification.has("restrictPropagationThroughLineage"),
                "Audit should include restrictPropagationThroughLineage field");
        assertEquals(true, auditClassification.get("restrictPropagationThroughLineage").asBoolean(),
                "MS-595 BUG: Entity audit must show restrictPropagationThroughLineage=true. " +
                "The propagation flags on currentClassification are never updated from the " +
                "request classification before being sent to the audit listener.");
    }

    // =========================================================================
    //  Test: simultaneous update of propagate + restrictPropagationThroughHierarchy
    // =========================================================================

    @Test
    @Order(6)
    @DisplayName("MS-595: switching restrict flags must be reflected in audit")
    void testSwitchRestrictFlag_AuditMustReflectAllChanges() throws Exception {
        Assumptions.assumeTrue(entityGuid != null, "Entity not created");

        // After Test 5: propagate=true, restrictLineage=true, restrictHierarchy=false
        // Update: switch from restrictLineage to restrictHierarchy
        // (Atlas does not allow both to be true simultaneously)
        AtlasClassification update = new AtlasClassification(classificationName);
        update.setEntityGuid(entityGuid);
        update.setPropagate(true);
        update.setRemovePropagationsOnEntityDelete(true);
        update.setRestrictPropagationThroughLineage(false);
        update.setRestrictPropagationThroughHierarchy(true);

        atlasClient.updateClassifications(entityGuid, Collections.singletonList(update));
        LOG.info("Updated: restrictLineage true → false, restrictHierarchy false → true");

        Thread.sleep(3000);

        // GET API
        AtlasClassifications classifications = atlasClient.getClassifications(entityGuid);
        AtlasClassification fetched = classifications.getList().stream()
                .filter(c -> c.getTypeName().equals(classificationName))
                .findFirst()
                .orElseThrow(() -> new AssertionError("Classification not found via GET"));
        assertTrue(fetched.isPropagate(), "GET: propagate should be true");
        assertFalse(fetched.getRestrictPropagationThroughLineage(),
                "GET: restrictPropagationThroughLineage should be false");
        assertTrue(fetched.getRestrictPropagationThroughHierarchy(),
                "GET: restrictPropagationThroughHierarchy should be true");

        // Audit
        JsonNode auditClassification = getLatestClassificationUpdateAuditDetail(entityGuid, classificationName);
        assertNotNull(auditClassification, "Should find CLASSIFICATION_UPDATE audit");

        assertEquals(true, auditClassification.get("propagate").asBoolean(),
                "MS-595: audit propagate must be true");
        assertEquals(false, auditClassification.get("restrictPropagationThroughLineage").asBoolean(),
                "MS-595: audit restrictPropagationThroughLineage must be false");
        assertEquals(true, auditClassification.get("restrictPropagationThroughHierarchy").asBoolean(),
                "MS-595: audit restrictPropagationThroughHierarchy must be true");
    }

    // =========================================================================
    //  Helper: query ES entity_audits index directly for CLASSIFICATION_UPDATE
    // =========================================================================

    /**
     * Queries the ES {@code entity_audits} index directly (via the testcontainer)
     * for the most recent CLASSIFICATION_UPDATE event matching the given entity and tag.
     *
     * <p>In ES, the audit stores the classification JSON directly in the {@code detail}
     * field (the "Updated classification: " prefix is stripped before indexing by
     * {@code ESBasedAuditRepository.putEventsV2()}).</p>
     *
     * @return the classification JsonNode from the latest matching audit, or null
     */
    private JsonNode getLatestClassificationUpdateAuditDetail(String guid, String tagName) throws Exception {
        String esBaseUrl = "http://" + getElasticsearchAddress();

        // Force ES to flush/refresh so recently indexed docs are searchable
        httpClient.send(HttpRequest.newBuilder()
                .uri(URI.create(esBaseUrl + "/entity_audits/_refresh"))
                .POST(HttpRequest.BodyPublishers.noBody())
                .timeout(Duration.ofSeconds(5))
                .build(), HttpResponse.BodyHandlers.ofString());

        // Query entity_audits index directly
        String esQuery = String.format("""
            {
                "sort": [{ "created": { "order": "desc" }}],
                "size": 10,
                "query": {
                    "bool": {
                        "must": [
                            { "term": { "entityId": "%s" }},
                            { "term": { "action": "CLASSIFICATION_UPDATE" }}
                        ]
                    }
                }
            }""", guid);

        // Retry loop for ES indexing latency
        for (int attempt = 0; attempt < 5; attempt++) {
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(esBaseUrl + "/entity_audits/_search"))
                    .header("Content-Type", "application/json")
                    .POST(HttpRequest.BodyPublishers.ofString(esQuery))
                    .timeout(Duration.ofSeconds(10))
                    .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                LOG.warn("ES search returned HTTP {} on attempt {}: {}",
                        response.statusCode(), attempt + 1, response.body());
                Thread.sleep(2000);
                continue;
            }

            JsonNode result = MAPPER.readTree(response.body());
            JsonNode hits = result.path("hits").path("hits");

            if (!hits.isArray() || hits.isEmpty()) {
                LOG.info("No CLASSIFICATION_UPDATE audits found yet, attempt {}/5", attempt + 1);
                Thread.sleep(2000);
                continue;
            }

            // Find the most recent audit whose detail.typeName matches the target tag
            for (JsonNode hit : hits) {
                JsonNode source = hit.get("_source");
                JsonNode detail = source != null ? source.get("detail") : null;
                if (detail != null && detail.has("typeName")
                        && tagName.equals(detail.get("typeName").asText())) {
                    LOG.info("Found CLASSIFICATION_UPDATE audit detail from ES: {}", detail);
                    return detail;
                }
            }

            LOG.info("Audits found but none match tag {}, attempt {}/5", tagName, attempt + 1);
            Thread.sleep(2000);
        }

        LOG.warn("No matching CLASSIFICATION_UPDATE audit found after retries for tag {}", tagName);
        return null;
    }
}
